"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.default = exports.GraphQLEngine = void 0;

require("../../utils/engines-fs-provider");

var _gatsbyCoreUtils = require("gatsby-core-utils");

var _index = require("../index");

var _lmdbDatastore = require("../../datastore/lmdb/lmdb-datastore");

var _redux = require("../../redux");

var _actions = require("../../redux/actions");

var _reporter = _interopRequireDefault(require("gatsby-cli/lib/reporter"));

var _createGraphqlRunner = require("../../bootstrap/create-graphql-runner");

var _waitUntilJobsComplete = require("../../utils/wait-until-jobs-complete");

var _requireGatsbyPlugin = require("../../utils/require-gatsby-plugin");

var _apiRunnerNode = _interopRequireDefault(require("../../utils/api-runner-node"));

var _findPageByPath = require("../../utils/find-page-by-path");

var _engineContext = require("../../utils/engine-context");

var _datastore = require("../../datastore");

var _queryEnginePlugins = require(".cache/query-engine-plugins");

// "engines-fs-provider" must be first import, as it sets up global
// fs and this need to happen before anything else tries to import fs
class GraphQLEngine {
  // private schema: GraphQLSchema
  constructor({
    dbPath
  }) {
    (0, _lmdbDatastore.setupLmdbStore)({
      dbPath
    }); // start initializing runner ASAP

    this.getRunner();
  }

  async _doGetRunner() {
    // @ts-ignore SCHEMA_SNAPSHOT is being "inlined" by bundler
    _redux.store.dispatch(_actions.actions.createTypes(SCHEMA_SNAPSHOT)); // TODO: FLATTENED_PLUGINS needs to be merged with plugin options from gatsby-config
    //  (as there might be non-serializable options, i.e. functions)


    _redux.store.dispatch({
      type: `SET_SITE_FLATTENED_PLUGINS`,
      payload: _queryEnginePlugins.flattenedPlugins
    });

    for (const pluginName of Object.keys(_queryEnginePlugins.gatsbyNodes)) {
      (0, _requireGatsbyPlugin.setGatsbyPluginCache)({
        name: pluginName,
        resolve: ``
      }, `gatsby-node`, _queryEnginePlugins.gatsbyNodes[pluginName]);
    }

    for (const pluginName of Object.keys(_queryEnginePlugins.gatsbyWorkers)) {
      (0, _requireGatsbyPlugin.setGatsbyPluginCache)({
        name: pluginName,
        resolve: ``
      }, `gatsby-worker`, _queryEnginePlugins.gatsbyWorkers[pluginName]);
    }

    if ("4" === `4`) {
      await (0, _apiRunnerNode.default)(`onPluginInit`);
    } else {
      await (0, _apiRunnerNode.default)(`unstable_onPluginInit`);
    }

    await (0, _apiRunnerNode.default)(`createSchemaCustomization`); // Build runs
    // Note: skipping inference metadata because we rely on schema snapshot

    await (0, _index.build)({
      fullMetadataBuild: false
    });
    return (0, _createGraphqlRunner.createGraphQLRunner)(_redux.store, _reporter.default);
  }

  async getRunner() {
    if (!this.runnerPromise) {
      this.runnerPromise = this._doGetRunner();
    }

    return this.runnerPromise;
  }

  async ready() {
    // We don't want to expose internal runner freely. We do expose `runQuery` function already.
    // The way internal runner works can change, so we should not make it a public API.
    // Here we just want to expose way to await it being ready
    await this.getRunner();
  }

  async runQuery(query, context) {
    const engineContext = {
      requestId: _gatsbyCoreUtils.uuid.v4()
    };

    const doRunQuery = async () => {
      const graphqlRunner = await this.getRunner();
      const result = await graphqlRunner(query, context);
      await (0, _waitUntilJobsComplete.waitJobsByRequest)(engineContext.requestId);
      return result;
    };

    try {
      return await (0, _engineContext.runWithEngineContext)(engineContext, doRunQuery);
    } finally {
      // Reset job-to-request mapping
      _redux.store.dispatch({
        type: `CLEAR_JOB_V2_CONTEXT`,
        payload: engineContext
      });
    }
  }

  findPageByPath(pathName) {
    // adapter so `findPageByPath` use SitePage nodes in datastore
    // instead of `pages` redux slice
    const state = {
      pages: {
        get(pathName) {
          return (0, _datastore.getDataStore)().getNode(`SitePage ${pathName}`);
        },

        values() {
          return (0, _datastore.getDataStore)().iterateNodesByType(`SitePage`);
        }

      }
    };
    return (0, _findPageByPath.findPageByPath)(state, pathName, false);
  }

}

exports.GraphQLEngine = GraphQLEngine;
var _default = {
  GraphQLEngine
};
exports.default = _default;
//# sourceMappingURL=entry.js.map