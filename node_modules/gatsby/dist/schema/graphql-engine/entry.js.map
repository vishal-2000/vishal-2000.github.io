{"version":3,"sources":["../../../src/schema/graphql-engine/entry.ts"],"names":["GraphQLEngine","constructor","dbPath","getRunner","_doGetRunner","store","dispatch","actions","createTypes","SCHEMA_SNAPSHOT","type","payload","flattenedPlugins","pluginName","Object","keys","gatsbyNodes","name","resolve","gatsbyWorkers","fullMetadataBuild","reporter","runnerPromise","ready","runQuery","query","context","engineContext","requestId","uuid","v4","doRunQuery","graphqlRunner","result","findPageByPath","pathName","state","pages","get","getNode","values","iterateNodesByType"],"mappings":"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","sourcesContent":["// \"engines-fs-provider\" must be first import, as it sets up global\n// fs and this need to happen before anything else tries to import fs\nimport \"../../utils/engines-fs-provider\"\n\nimport { ExecutionResult, Source } from \"graphql\"\nimport { uuid } from \"gatsby-core-utils\"\nimport { build } from \"../index\"\nimport { setupLmdbStore } from \"../../datastore/lmdb/lmdb-datastore\"\nimport { store } from \"../../redux\"\nimport { actions } from \"../../redux/actions\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport {\n  createGraphQLRunner,\n  Runner,\n} from \"../../bootstrap/create-graphql-runner\"\nimport { waitJobsByRequest } from \"../../utils/wait-until-jobs-complete\"\n\nimport { setGatsbyPluginCache } from \"../../utils/require-gatsby-plugin\"\nimport apiRunnerNode from \"../../utils/api-runner-node\"\nimport type { IGatsbyPage, IGatsbyState } from \"../../redux/types\"\nimport { findPageByPath } from \"../../utils/find-page-by-path\"\nimport { runWithEngineContext } from \"../../utils/engine-context\"\nimport { getDataStore } from \"../../datastore\"\nimport {\n  gatsbyNodes,\n  gatsbyWorkers,\n  flattenedPlugins,\n  // @ts-ignore\n} from \".cache/query-engine-plugins\"\n\nexport class GraphQLEngine {\n  // private schema: GraphQLSchema\n  private runnerPromise?: Promise<Runner>\n\n  constructor({ dbPath }: { dbPath: string }) {\n    setupLmdbStore({ dbPath })\n    // start initializing runner ASAP\n    this.getRunner()\n  }\n\n  private async _doGetRunner(): Promise<Runner> {\n    // @ts-ignore SCHEMA_SNAPSHOT is being \"inlined\" by bundler\n    store.dispatch(actions.createTypes(SCHEMA_SNAPSHOT))\n\n    // TODO: FLATTENED_PLUGINS needs to be merged with plugin options from gatsby-config\n    //  (as there might be non-serializable options, i.e. functions)\n    store.dispatch({\n      type: `SET_SITE_FLATTENED_PLUGINS`,\n      payload: flattenedPlugins,\n    })\n\n    for (const pluginName of Object.keys(gatsbyNodes)) {\n      setGatsbyPluginCache(\n        { name: pluginName, resolve: `` },\n        `gatsby-node`,\n        gatsbyNodes[pluginName]\n      )\n    }\n    for (const pluginName of Object.keys(gatsbyWorkers)) {\n      setGatsbyPluginCache(\n        { name: pluginName, resolve: `` },\n        `gatsby-worker`,\n        gatsbyWorkers[pluginName]\n      )\n    }\n    if (_CFLAGS_.GATSBY_MAJOR === `4`) {\n      await apiRunnerNode(`onPluginInit`)\n    } else {\n      await apiRunnerNode(`unstable_onPluginInit`)\n    }\n    await apiRunnerNode(`createSchemaCustomization`)\n\n    // Build runs\n    // Note: skipping inference metadata because we rely on schema snapshot\n    await build({ fullMetadataBuild: false })\n\n    return createGraphQLRunner(store, reporter)\n  }\n\n  private async getRunner(): Promise<Runner> {\n    if (!this.runnerPromise) {\n      this.runnerPromise = this._doGetRunner()\n    }\n    return this.runnerPromise\n  }\n\n  public async ready(): Promise<void> {\n    // We don't want to expose internal runner freely. We do expose `runQuery` function already.\n    // The way internal runner works can change, so we should not make it a public API.\n    // Here we just want to expose way to await it being ready\n    await this.getRunner()\n  }\n\n  public async runQuery(\n    query: string | Source,\n    context: Record<string, any>\n  ): Promise<ExecutionResult> {\n    const engineContext = {\n      requestId: uuid.v4(),\n    }\n    const doRunQuery = async (): Promise<ExecutionResult> => {\n      const graphqlRunner = await this.getRunner()\n      const result = await graphqlRunner(query, context)\n      await waitJobsByRequest(engineContext.requestId)\n      return result\n    }\n    try {\n      return await runWithEngineContext(engineContext, doRunQuery)\n    } finally {\n      // Reset job-to-request mapping\n      store.dispatch({\n        type: `CLEAR_JOB_V2_CONTEXT`,\n        payload: engineContext,\n      })\n    }\n  }\n\n  public findPageByPath(pathName: string): IGatsbyPage | undefined {\n    // adapter so `findPageByPath` use SitePage nodes in datastore\n    // instead of `pages` redux slice\n    const state = {\n      pages: {\n        get(pathName: string): IGatsbyPage | undefined {\n          return getDataStore().getNode(`SitePage ${pathName}`) as\n            | IGatsbyPage\n            | undefined\n        },\n        values(): Iterable<IGatsbyPage> {\n          return getDataStore().iterateNodesByType(\n            `SitePage`\n          ) as Iterable<IGatsbyPage>\n        },\n      },\n    } as unknown as IGatsbyState\n\n    return findPageByPath(state, pathName, false)\n  }\n}\n\nexport default { GraphQLEngine }\n"],"file":"entry.js"}