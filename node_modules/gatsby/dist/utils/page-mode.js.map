{"version":3,"sources":["../../src/utils/page-mode.ts"],"names":["getPageMode","page","state","components","store","getState","component","get","componentPath","serverData","resolvePageMode","pageMode","defer","path","materializePageMode","pages","dispatchCount","values","Error","action","type","payload","dispatch","Promise","resolve","setImmediate"],"mappings":";;;;;;AAAA;;AAOA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,WAAT,CAAqBC,IAArB,EAAwCC,KAAxC,EAAwE;AAAA;;AAC7E,QAAM;AAAEC,IAAAA;AAAF,MAAiBD,KAAjB,aAAiBA,KAAjB,cAAiBA,KAAjB,GAA0BE,aAAMC,QAAN,EAAhC,CAD6E,CAG7E;;AACA,QAAMC,SAAS,sBAAGH,UAAU,CAACI,GAAX,CAAeN,IAAI,CAACO,aAApB,CAAH,6DAAyC;AAAEC,IAAAA,UAAU,EAAE;AAAd,GAAxD,CAJ6E,CAM7E;AACA;AACA;AACA;AACA;AACA;;AACA,SAAOC,eAAe,CAACT,IAAD,EAAOK,SAAP,CAAtB;AACD;;AAED,SAASI,eAAT,CACET,IADF,EAEEK,SAFF,EAKY;AACV,MAAIK,QAAJ;;AACA,MAAIL,SAAS,CAACG,UAAd,EAA0B;AACxBE,IAAAA,QAAQ,GAAI,KAAZ;AACD,GAFD,MAEO;AACLA,IAAAA,QAAQ,GAAGV,IAAI,CAACW,KAAL,GAAc,KAAd,GAAsB,KAAjC;AACD,GANS,CAOV;AACA;AACA;AACA;;;AACA,MACED,QAAQ,KAAM,KAAd,KACCV,IAAI,CAACY,IAAL,KAAe,WAAf,IAA6BZ,IAAI,CAACY,IAAL,KAAe,WAD7C,CADF,EAGE;AACA,gCACG,gBAAeZ,IAAI,CAACY,IAAK,yBAAwBF,QAAS,mEAD7D;AAGAA,IAAAA,QAAQ,GAAI,KAAZ;AACD;;AAED,SAAOA,QAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,eAAeG,mBAAf,GAAoD;AACzD,QAAM;AAAEC,IAAAA,KAAF;AAASZ,IAAAA;AAAT,MAAwBC,aAAMC,QAAN,EAA9B;;AAEA,MAAIW,aAAa,GAAG,CAApB;;AACA,OAAK,MAAMf,IAAX,IAAmBc,KAAK,CAACE,MAAN,EAAnB,EAAmC;AACjC,UAAMX,SAAS,GAAGH,UAAU,CAACI,GAAX,CAAeN,IAAI,CAACO,aAApB,CAAlB;;AACA,QAAI,CAACF,SAAL,EAAgB;AACd,YAAM,IAAIY,KAAJ,CAAW,8CAA6CjB,IAAI,CAACY,IAAK,EAAlE,CAAN;AACD;;AACD,UAAMF,QAAQ,GAAGD,eAAe,CAACT,IAAD,EAAOK,SAAP,CAAhC,CALiC,CAOjC;AACA;AACA;;AACA,QAAIK,QAAQ,KAAM,KAAlB,EAAwB;AACtB,YAAMQ,MAA4B,GAAG;AACnCC,QAAAA,IAAI,EAAG,uBAD4B;AAEnCC,QAAAA,OAAO,EAAE;AAAER,UAAAA,IAAI,EAAEZ,IAAI,CAACY,IAAb;AAAmBF,UAAAA;AAAnB;AAF0B,OAArC;;AAIAP,mBAAMkB,QAAN,CAAeH,MAAf;AACD,KAhBgC,CAiBjC;;;AACA,QAAIH,aAAa,KAAK,GAAlB,KAA0B,CAA9B,EAAiC;AAC/B,YAAM,IAAIO,OAAJ,CAAYC,OAAO,IAAIC,YAAY,CAACD,OAAD,CAAnC,CAAN;AACD;AACF;AACF","sourcesContent":["import { store } from \"../redux\"\nimport {\n  IGatsbyPage,\n  IGatsbyState,\n  IMaterializePageMode,\n  PageMode,\n} from \"../redux/types\"\nimport { reportOnce } from \"./report-once\"\n\n/**\n * In develop IGatsbyPage[\"mode\"] can change at any time, so as a general rule we need to resolve it\n * every time from page component and IGatsbyPage[\"defer\"] value.\n *\n * IGatsbyPage[\"mode\"] is only reliable in engines and in `onPostBuild` hook.\n */\nexport function getPageMode(page: IGatsbyPage, state?: IGatsbyState): PageMode {\n  const { components } = state ?? store.getState()\n\n  // assume SSG until components are actually extracted\n  const component = components.get(page.componentPath) ?? { serverData: false }\n\n  // TODO: fs routes support:\n  //   if (component.config) {\n  //     const renderer = require(PAGE_RENDERER_PATH)\n  //     const componentInstance = await renderer.getPageChunk({ componentChunkName: page.componentChunkName })\n  //     return resolvePageMode(page, component, componentInstance)\n  //   }\n  return resolvePageMode(page, component)\n}\n\nfunction resolvePageMode(\n  page: IGatsbyPage,\n  component: { serverData: boolean }\n  // TODO:\n  //  componentInstance?: NodeModule\n): PageMode {\n  let pageMode: PageMode\n  if (component.serverData) {\n    pageMode = `SSR`\n  } else {\n    pageMode = page.defer ? `DSG` : `SSG`\n  }\n  // TODO: fs routes support, e.g.:\n  //   if (componentInstance) {\n  //     return componentInstance.config.defer(page) ? `DSG` : `SSG`\n  //   }\n  if (\n    pageMode !== `SSG` &&\n    (page.path === `/404.html` || page.path === `/500.html`)\n  ) {\n    reportOnce(\n      `Status page \"${page.path}\" ignores page mode (\"${pageMode}\") and force sets it to SSG (this page can't be lazily rendered).`\n    )\n    pageMode = `SSG`\n  }\n\n  return pageMode\n}\n\n/**\n * Persist page.mode for SSR/DSG pages to ensure they work with `gatsby serve`\n *\n * TODO: ideally IGatsbyPage[\"mode\"] should not exist at all and instead we need a different entity\n *   holding this information: an entity that is only created in the end of the build e.g. Route\n *   then materializePageMode transforms to createRoutes\n */\nexport async function materializePageMode(): Promise<void> {\n  const { pages, components } = store.getState()\n\n  let dispatchCount = 0\n  for (const page of pages.values()) {\n    const component = components.get(page.componentPath)\n    if (!component) {\n      throw new Error(`Could not find matching component for page ${page.path}`)\n    }\n    const pageMode = resolvePageMode(page, component)\n\n    // Do not materialize for SSG pages: saves some CPU time as `page.mode` === `SSG` by default when creating a page\n    // and our pages are re-generated on each build, not persisted\n    // (so no way to get DSG/SSR value from the previous build)\n    if (pageMode !== `SSG`) {\n      const action: IMaterializePageMode = {\n        type: `MATERIALIZE_PAGE_MODE`,\n        payload: { path: page.path, pageMode },\n      }\n      store.dispatch(action)\n    }\n    // Do not block task queue of the event loop for too long:\n    if (dispatchCount++ % 100 === 0) {\n      await new Promise(resolve => setImmediate(resolve))\n    }\n  }\n}\n"],"file":"page-mode.js"}