{"version":3,"sources":["../../../src/utils/page-ssr-module/entry.ts"],"names":["pageTemplateDetailsMap","INLINED_TEMPLATE_TO_DETAILS","getData","pathName","graphqlEngine","req","potentialPagePath","page","findPageByPath","Error","templateDetails","componentChunkName","executionPromises","results","serverData","query","push","runQuery","context","then","queryResults","errors","length","e","codeFrame","locations","line","column","queryRunningError","message","stack","mode","mod","serverDataResults","Promise","all","props","pageContext","searchString","maybeQueryString","Object","entries","map","k","v","join","serverDataHeaders","headers","getPath","data","matchPath","path","renderPageData","staticQueryHashes","JSON","stringify","parse","readStaticQueryContext","templatePath","filePath","__dirname","rawSQContext","fs","readFile","renderHTML","pageData","staticQueryContext","pagePath","assets","inlinePageData","html"],"mappings":"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","sourcesContent":["// \"engines-fs-provider\" must be first import, as it sets up global\n// fs and this need to happen before anything else tries to import fs\nimport \"../engines-fs-provider\"\n\n// just types - those should not be bundled\nimport type { GraphQLEngine } from \"../../schema/graphql-engine/entry\"\nimport type { IExecutionResult } from \"../../query/types\"\nimport type { IGatsbyPage } from \"../../redux/types\"\nimport type { IScriptsAndStyles } from \"../client-assets-for-template\"\nimport type { IPageDataWithQueryResult } from \"../page-data\"\nimport type { Request } from \"express\"\n\n// actual imports\nimport * as path from \"path\"\nimport * as fs from \"fs-extra\"\nimport {\n  constructPageDataString,\n  getPagePathFromPageDataPath,\n} from \"../page-data-helpers\"\n// @ts-ignore render-page import will become valid later on (it's marked as external)\nimport htmlComponentRenderer, { getPageChunk } from \"./routes/render-page\"\nimport { getServerData, IServerData } from \"../get-server-data\"\nimport { getCodeFrame } from \"../../query/graphql-errors-codeframe\"\n\nexport interface ITemplateDetails {\n  query: string\n  staticQueryHashes: Array<string>\n  assets: IScriptsAndStyles\n}\nexport interface ISSRData {\n  results: IExecutionResult\n  page: IGatsbyPage\n  templateDetails: ITemplateDetails\n  potentialPagePath: string\n  serverDataHeaders?: Record<string, string>\n  searchString: string\n}\n\nconst pageTemplateDetailsMap: Record<\n  string,\n  ITemplateDetails\n  // @ts-ignore INLINED_TEMPLATE_TO_DETAILS is being \"inlined\" by bundler\n> = INLINED_TEMPLATE_TO_DETAILS\n\nexport async function getData({\n  pathName,\n  graphqlEngine,\n  req,\n}: {\n  graphqlEngine: GraphQLEngine\n  pathName: string\n  req?: Partial<Pick<Request, \"query\" | \"method\" | \"url\" | \"headers\">>\n}): Promise<ISSRData> {\n  const potentialPagePath = getPagePathFromPageDataPath(pathName) || pathName\n\n  // 1. Find a page for pathname\n  const page = graphqlEngine.findPageByPath(potentialPagePath)\n\n  if (!page) {\n    // page not found, nothing to run query for\n    throw new Error(`Page for \"${pathName}\" not found`)\n  }\n\n  // 2. Lookup query used for a page (template)\n  const templateDetails = pageTemplateDetailsMap[page.componentChunkName]\n  if (!templateDetails) {\n    throw new Error(\n      `Page template details for \"${page.componentChunkName}\" not found`\n    )\n  }\n\n  const executionPromises: Array<Promise<any>> = []\n\n  // 3. Execute query\n  // query-runner handles case when query is not there - so maybe we should consider using that somehow\n  let results: IExecutionResult = {}\n  let serverData: IServerData | undefined\n  if (templateDetails.query) {\n    executionPromises.push(\n      graphqlEngine\n        .runQuery(templateDetails.query, {\n          ...page,\n          ...page.context,\n        })\n        .then(queryResults => {\n          if (queryResults.errors && queryResults.errors.length > 0) {\n            const e = queryResults.errors[0]\n            const codeFrame = getCodeFrame(\n              templateDetails.query,\n              e.locations && e.locations[0].line,\n              e.locations && e.locations[0].column\n            )\n\n            const queryRunningError = new Error(e.message + `\\n\\n` + codeFrame)\n            queryRunningError.stack = e.stack\n            throw queryRunningError\n          } else {\n            results = queryResults\n          }\n        })\n    )\n  }\n\n  // 4. (if SSR) run getServerData\n  if (page.mode === `SSR`) {\n    executionPromises.push(\n      getPageChunk(page)\n        .then(mod => getServerData(req, page, potentialPagePath, mod))\n        .then(serverDataResults => {\n          serverData = serverDataResults\n        })\n    )\n  }\n\n  await Promise.all(executionPromises)\n\n  if (serverData) {\n    results.serverData = serverData.props\n  }\n  results.pageContext = page.context\n\n  let searchString = ``\n  if (req?.query) {\n    const maybeQueryString = Object.entries(req.query)\n      .map(([k, v]) => `${k}=${v}`)\n      .join(`&`)\n    if (maybeQueryString) {\n      searchString = `?${maybeQueryString}`\n    }\n  }\n\n  return {\n    results,\n    page,\n    templateDetails,\n    potentialPagePath,\n    serverDataHeaders: serverData?.headers,\n    searchString,\n  }\n}\n\nfunction getPath(data: ISSRData): string {\n  return (\n    (data.page.mode !== `SSG` && data.page.matchPath\n      ? data.potentialPagePath\n      : data.page.path) + (data.page.mode === `SSR` ? data.searchString : ``)\n  )\n}\n\nexport async function renderPageData({\n  data,\n}: {\n  data: ISSRData\n}): Promise<IPageDataWithQueryResult> {\n  const results = await constructPageDataString(\n    {\n      componentChunkName: data.page.componentChunkName,\n      path: getPath(data),\n      matchPath: data.page.matchPath,\n      staticQueryHashes: data.templateDetails.staticQueryHashes,\n    },\n    JSON.stringify(data.results)\n  )\n\n  return JSON.parse(results)\n}\n\nconst readStaticQueryContext = async (\n  templatePath: string\n): Promise<Record<string, { data: unknown }>> => {\n  const filePath = path.join(\n    __dirname,\n    `sq-context`,\n    templatePath,\n    `sq-context.json`\n  )\n  const rawSQContext = await fs.readFile(filePath, `utf-8`)\n\n  return JSON.parse(rawSQContext)\n}\n\nexport async function renderHTML({\n  data,\n  pageData,\n}: {\n  data: ISSRData\n  pageData?: IPageDataWithQueryResult\n}): Promise<string> {\n  if (!pageData) {\n    pageData = await renderPageData({ data })\n  }\n\n  const staticQueryContext = await readStaticQueryContext(\n    data.page.componentChunkName\n  )\n\n  const results = await htmlComponentRenderer({\n    pagePath: getPath(data),\n    pageData,\n    staticQueryContext,\n    ...data.templateDetails.assets,\n    inlinePageData: data.page.mode === `SSR` && data.results.serverData,\n  })\n\n  return results.html\n}\n"],"file":"entry.js"}