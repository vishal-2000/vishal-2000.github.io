"use strict";

exports.__esModule = true;
exports.getData = getData;
exports.renderPageData = renderPageData;
exports.renderHTML = renderHTML;

require("../engines-fs-provider");

var path = _interopRequireWildcard(require("path"));

var fs = _interopRequireWildcard(require("fs-extra"));

var _pageDataHelpers = require("../page-data-helpers");

var _renderPage = _interopRequireWildcard(require("./routes/render-page"));

var _getServerData = require("../get-server-data");

var _graphqlErrorsCodeframe = require("../../query/graphql-errors-codeframe");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// "engines-fs-provider" must be first import, as it sets up global
// fs and this need to happen before anything else tries to import fs
// actual imports
// @ts-ignore render-page import will become valid later on (it's marked as external)
const pageTemplateDetailsMap = INLINED_TEMPLATE_TO_DETAILS;

async function getData({
  pathName,
  graphqlEngine,
  req
}) {
  var _serverData;

  const potentialPagePath = (0, _pageDataHelpers.getPagePathFromPageDataPath)(pathName) || pathName; // 1. Find a page for pathname

  const page = graphqlEngine.findPageByPath(potentialPagePath);

  if (!page) {
    // page not found, nothing to run query for
    throw new Error(`Page for "${pathName}" not found`);
  } // 2. Lookup query used for a page (template)


  const templateDetails = pageTemplateDetailsMap[page.componentChunkName];

  if (!templateDetails) {
    throw new Error(`Page template details for "${page.componentChunkName}" not found`);
  }

  const executionPromises = []; // 3. Execute query
  // query-runner handles case when query is not there - so maybe we should consider using that somehow

  let results = {};
  let serverData;

  if (templateDetails.query) {
    executionPromises.push(graphqlEngine.runQuery(templateDetails.query, { ...page,
      ...page.context
    }).then(queryResults => {
      if (queryResults.errors && queryResults.errors.length > 0) {
        const e = queryResults.errors[0];
        const codeFrame = (0, _graphqlErrorsCodeframe.getCodeFrame)(templateDetails.query, e.locations && e.locations[0].line, e.locations && e.locations[0].column);
        const queryRunningError = new Error(e.message + `\n\n` + codeFrame);
        queryRunningError.stack = e.stack;
        throw queryRunningError;
      } else {
        results = queryResults;
      }
    }));
  } // 4. (if SSR) run getServerData


  if (page.mode === `SSR`) {
    executionPromises.push((0, _renderPage.getPageChunk)(page).then(mod => (0, _getServerData.getServerData)(req, page, potentialPagePath, mod)).then(serverDataResults => {
      serverData = serverDataResults;
    }));
  }

  await Promise.all(executionPromises);

  if (serverData) {
    results.serverData = serverData.props;
  }

  results.pageContext = page.context;
  let searchString = ``;

  if (req !== null && req !== void 0 && req.query) {
    const maybeQueryString = Object.entries(req.query).map(([k, v]) => `${k}=${v}`).join(`&`);

    if (maybeQueryString) {
      searchString = `?${maybeQueryString}`;
    }
  }

  return {
    results,
    page,
    templateDetails,
    potentialPagePath,
    serverDataHeaders: (_serverData = serverData) === null || _serverData === void 0 ? void 0 : _serverData.headers,
    searchString
  };
}

function getPath(data) {
  return (data.page.mode !== `SSG` && data.page.matchPath ? data.potentialPagePath : data.page.path) + (data.page.mode === `SSR` ? data.searchString : ``);
}

async function renderPageData({
  data
}) {
  const results = await (0, _pageDataHelpers.constructPageDataString)({
    componentChunkName: data.page.componentChunkName,
    path: getPath(data),
    matchPath: data.page.matchPath,
    staticQueryHashes: data.templateDetails.staticQueryHashes
  }, JSON.stringify(data.results));
  return JSON.parse(results);
}

const readStaticQueryContext = async templatePath => {
  const filePath = path.join(__dirname, `sq-context`, templatePath, `sq-context.json`);
  const rawSQContext = await fs.readFile(filePath, `utf-8`);
  return JSON.parse(rawSQContext);
};

async function renderHTML({
  data,
  pageData
}) {
  if (!pageData) {
    pageData = await renderPageData({
      data
    });
  }

  const staticQueryContext = await readStaticQueryContext(data.page.componentChunkName);
  const results = await (0, _renderPage.default)({
    pagePath: getPath(data),
    pageData,
    staticQueryContext,
    ...data.templateDetails.assets,
    inlinePageData: data.page.mode === `SSR` && data.results.serverData
  });
  return results.html;
}
//# sourceMappingURL=entry.js.map